видео курса:
https://www.youtube.com/watch?v=kz23xxukY5s&t=916s
нужно скачать nodeJS и установить
потом ставим реакт через vite. Он лучше чем вебпак. Работает лучше ставит быстрее и ошибок меньше
npm create vite@latest
эту команду нужно ввести в папке с проектом
далее vite будет подсказывать как установить и запустить проект

компоненты!!!!!!!!!!!!!!!!!!!!!!!!
Переиспользуемые
Разделение и изоляция логики
Проще разрабатывать интерфейс
HTML & CSS & JS лежат вместе
Используется везде

Структура проекта!!!!!!!!!!!!!!
оставил в папке src файлы:
main.jsx
index.css
App.jsx
data.js - этот файл руками создал

переделал main.jsx
убрал лишние импорты и оставил это:
const root = document.getElementById('root')
ReactDOM.createRoot(root).render(<App />)

html файл в который идет весь функционал идет в файл index.html он лежит в корне проекта, а не в папке public
getElementById ищет элемент в файле index.html
в самом html там кода мало. В основном весь контент идет из реакта
то есть в файле main.jsx мы берем приложение наше App.jsx и из него идет фунционал
сам javascript не понимает html теги и код html, но есть специальные сборщики vite или вебпак, они их преобразовывают, и отображают страницы
при эжелании можно поставить код форматтер preeter в VScode, он автомаом форатирует текст по отступам при сохранении
мы функцию App экспортируем и импортируем в другом файле.
потом вызываем ее в теге <App />
чтобы в реакте сделать компонент нужно создать функцию и написать и вернуть в ней шаблон, и экпортировать, потом импортировать и вызать в другом файле
названия компонентов всегда нужно писать с большой буквы

расширение jsx сделано для удобства, чтобы было понятно что в файле будет код jsx
компоненты можно выводить по несколько раз
когда мы в тегах пишем фигурные скобки, там можно писать любой JS код, и он будет интерпретироваться как шаблон
чтобы вывести что-то динамеческое, нужно написать что-то что можно привести к типу строка
импорт картинок просто через импорт как компонента только нужно прописать путь к файлу картинки

параметры в компонентах!!!!!!!!!!!!!!!!
название параметра может быть любым, но обычно пишут props как название параметра
сами значения компонентов нужно писать при вызове функции компонента. В самом компоненте их можно и не юзать, но в функцию они закидываются автоматически. И писать их можно сколько угодно скорее всего. Юзать все не обяз. Но лучше конечно делать все ровно, сколько написал компонентов столько и юзать.
есть оператор спред, выглядит как ...
он означает что мы берем последовательность. Лучше загуглить что она значит
циклы в jsx не работают, либо я не знаю как из делать
также можно вместо props писать названия самих компонентов
сделаем компонент Button.jsx
для отдельных компонентов лучше делать отдельный файл css в папке components
лучше также делать отдельные папки под компоненты. Так как в случае когда компонентов станет много, чтобы не было путаницы
можно еще вместо параметров или props писать в фигурных скобках слово children
тогда можно вызывать компонент как обычный тег html, и между открывающим и закрывающим тегом писать какую либо конструкцию html, тогда эта вся конструкция будет прокидываться в параметр
например так: <Button><h3>Круто</h3> <h1>коржик компот</h1> </Button>
Button это наша функция компонент
а обычно мы пишем так: <Button text="Кнопарь" />
слушатели событий начинаются с on
писать их нужно в компоненте, там где писали className
слушателей событий очень много
самый базовый это onClick
пишем так: onClick={}
в фигурных скобках передаем фукнцию, которая будет выполняться при клике на кнопку
саму функцию нужно прописать выше return
и функцию передаем в слушатель событий без вызова. Если передать с вызовом, то сработает 1 раз при запуске сайта и все, а при клике не будет работать
onMouseEnter={функция которая будет срабатывать}
это слушатель при наведении мышкой
также можно сразу в слушателе событий написать стрелочную функцию, а не писать функцию отдельно выше return. Так тоже можно.
onDoubleClick={() => console.log("двойной клик")}
функцию в функции создавать можно и это норм в JS так можно
желательно функцию которая будет срабатывать прописать в файле App.jsx
чтобы в разные кнопки прокидывался разный функционал
можно также передавать параметр функции как фунцию, то есть в этот параметр будет передаваться функция, название параметра можно писать любое

в css можно передавать параметры!!!!!!!!!!!
то есть прописали стили для кнопки, а потом дописали параметр название класса.названия параметра и в нем доп стили будут, которые можно применить при желании
также в JSX в параметре как функции можно передавать функцию с параметром как стрелочную функцию
и потом этот параметр как использовать. То есть создаем компонент, в него как параметр передаем функцию, и у этой функции есть параметр.

React State!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Теперь создадим переменную
let param = "asd"
и выведем ее внизу в параграфе
Потом в нашей функции с параметром переприсвоим значения в этой переменной, присвоим ей значение нашего параметра type
В консоли он выводится корректно. А в параграфе он не меняется, хотя мы присваиваем другое значение в эту переменную
в реакте обычные переменные не меняются, и для этого есть специальный функционал - состояния или State
если какая либо переменная будет состоянием или компоннет будет состоянием, то он на странице будет меняться при его изменении
можно еще протестить обновление страницы, написав в основной функции какой-то console.log, и понажимать кнопки. Наш console.log не будет повторно вызываться, так как страница не обновляется, а срабатывает только кнопка, которая у нас чтото выводит в консоль
как работать со State!!!!!!!!!!!!!!!!!!!!!
импортируем из реакт
import { useState } from 'react'
useState это функция, и она начинаются с префикса use, это означает что это хук с помощью которого мы можем создавать локальное состояние для компонента
можно создавать State как const или let, формат все равно один будет. Обычно пишут const. Состояние это всегда некий массив!!!!!!!!!!
State нельзя писать вне компонента. Всегда внутри функции компонента
состояния нужно создавать только на верхнем уровне по коду в функции, то есть в самом начале кода функции. Нельзя писать условие, типа если что-то то создаем State, так нельзя
если вывести в консоль наше состояние, то он выводится как массив.
пример состояние ниже, он так выглядит в консоли:
0: "Нажми на кнопку"
1: ƒ ()

В нем первый элемент это значение состояния, а второй элемент это функция позволяющая изменять этот State
то есть в состоянии есть 2 элемента как минимум, это значение состояния и функция которая может изменять состояние.
И эту функцию всегда прописывают с препиской set. Например, если состояние называется content, то функция для изменения состояния setContent. И в переменную content пишем значение состояния, а в переменную setContent функцию которая изменяет состояние
например так:
const stateArray = useState("Нажми на кнопку")//создали состояние
const content = stateArray[0]
const setContent = stateArray[1]
но так писать не удобно, и обычно так не пишут
чаще всего пишут так:
const [content, setContent] = useState("Нажми на кнопку")
тут как в питоне массиву переменных присваивается массив значений, и распределяется соответственно. Первому элементу значение, второй элементу функция, которая изменяет состояние
и мы не напрямую меняем переменную content, а используем функцию setContent, и в нее передаем параметр с нужным значением
И теперь при нажатии на кнопку меняется контент внизу. 
Также сделаем консоль логи на странице и в баттоне, и при загрузке страницы у нас эти логи выводятся, и также при изменении состояния они тоже выводятся.
Прописал в компоненте Button вывод с консоль, и в App компоненте, и при нажатии тоже консоль лог
При срабатывании изменения состояния все компоненты отрисовываются то есть рендерятся повторно. Странно
пока уберем логи в консоли
мы вызывали функцию вложенную в кнопках, и она возвращала просто строку, которая ей передавали как параметр
А теперь сделаем так, чтобы выводился коннент из объекта. Сделал словарь для примера. 
И в параграфе который у нас менялся постоянно пропишем это:
<p>{json_example[content]}</p>
json_example - это словарь как бы, а content это будет меняющийся ключ. То есть в переменную content мы меняем как состояние и изменяем ее значение. Значения у нас подставляются именно те, которые совпадают с ключами из json_example
по умолчанию content равен "Нажми на кнопку", и он не совпадает и с одним ключом. Поэтому так выводится. То есть можно как-то закидывать название клюей словаря, и отображать их
ВАЖНО!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
в функции когда мы изменяем переменную состояния (например изменили переменную content с помощью функции setContent), то она будет изменена, только при следующем рендере, и в коде с новым значеним сразу работать нельзя
то есть например у нас функция, которая изменяет значение, в ней мы пишем:
setContent(type)
console.log(content)
в консоль выведется все еще старое значение, точнее предыдущее значение. Если потом нажать на другую кнопку, то выведется значение предыдущей кнопки. 
Рендер сработает только при повторном нажатии на кнопку, либо нажатии на другую кнопку. Обновление страницы все сбросит
чтобы сделать время на странице можно прописать следующее:
const [time_now, setTime_now] = useState(new Date()) 
setInterval(() => setTime_now(new Date(), 1000))
и на страницу вывести наше состояние. Теперь будет тикать время каждую секунду. 
рендерится при этом только span, то есть тег где мы пишем состояние. Такое состояние кушет не очень много ресурса. 

далее у нас не выводится по умолчанию никакой объет, так как передается текст которого нет в словаре
условия с тернарным оператором:
{ contentType ? 
( <p>{json_example[contentType]}</p> ) :
( <p>Нажми на кнопку</p> )
}

тоже самое с null
{contentType ? 
<p>{json_example[contentType]}</p>:
null
}
{!contentType ? 
<p>Нажми на кнопку</p>:
null
}

обычное условие
{!contentType && <p>Нажми на кнопку</p> } тут если нет контента, то выводится текст Нажми на кнопку
{ contentType && <p>{json_example[contentType]}</p>} тут если есть контент то выводится элемент словаря

еще один вариант
сделаем отдельную переменную
let tabContent = null
и пропишем условие следующее
if (contentType){
tabContent = <p>{json_example[contentType]}</p>
}
else{
tabContent = <p>Нажми на кнопку</p>
}
jsx можно юзать вне return тоже

и все точно также работает. Также можно до return также делать различные конструкции

сделаем на кнопку активна или неактивна!!!!!!!!!!!!!!!!!!!!
для этого добавим параметр isActive в функцию Button 
и в className в теге button в функции Button пропишем это условие {isActive ? 'button active': 'button'}
и нужно параметр isActive определить при вызове компонента Button
isActive={contentType==="bla"}
напишем так. И при нажатии на кнопку у нас contentType меняется, и условие становится истинным

или
можно создать переменную
let classes = 'button'
if (isActive) classes += ' active'
и в случае если тру в isActive, то будет сложение строк

итерация массива в JSX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
для перебора массива есть map, он преобразовывает его в другой массив
его можно прописать так: 
{massiv.map(el => <Example_method {...el} />)}
или так более понятно выглядит:
{massiv.map( (el) => {
    return <Example_method {...el} />
    }
)}

где, massiv это переменная нашего массива, el это переменная для итерации массива, Example_method это метод компонента, {...el} это как бы перебор элементов такой
также при переборе массива в возвращаемом компоненте нужно передатьва key, как бы ключ массива
если не передать то выйдет ошибка в консоли:
Each child in a list should have a unique "key" prop.
это нужно чтобы реакт корректно мог изменять массив, то есть ключ передавать надо. Обычно ключ это какое-либо уникальное значение массива, например ID. В нашем случае это будет title
пропишем так:
{massiv.map( (el) => {
    return <Example_method key={el.title} {...el} />
    }
)}

разделение на компоненты!!!!!!!!!!!!!!!!!!!!!!!!!!!
вынесем первую секцию в отдельный файл как компонент
вынес обе секции в отдельные компоненты файлыи и перенс туда же массивы и Json объекты
импорты тоже все поменял
и ипортировал вынесенные функции в файл App.jsx

почему нужно всегда иметь корневой элемент
при возврате функции возвращаемые занчения в JS можно объединять в группы. Но нельзя возвращать 2 значения. ТО есть возвращаемое значение должно быть всегда одно
если возвращать 2 значения, то возвращается все равно одно
Можно возвразать массив из значений, но просто 2 значения нельзя возвращать
поэтому когда мы возвращаем в jsx несколько тегов, то будет выходить ошибка, так как это не теги, а результаты работы функций
как избавиться от оборачивания jsx в одном теге? Описание ниже!!!!!!!!!!!!!!!!!!!
импортируем из реакта Fragment
import { Fragment } from 'react'
в коде у нас как бы есть корневой элемент с Fragment в коде, но в ДОМ дереве его не будет, а раньше у нас был лишний div
но можно и не писать тег Fragment, а вместо этого юзать пустой тег <> </>, в дом дереве также будет пусто и не будет лишниъ тегов

Что из себя представляет jsx!!!!!!!!!!!
создадим файл в компонентах introSection.jsx
сделаем там компонент для секции с заголовками. Моэжно также писать стили в тегах
рядом с className пропишем это style={{ color: '#666' }}
и присвоится стиль налету
Также нее обяз использовать именно структуру как в jsx, на практике конечно надо юзать, но можно и без этой структуры jsx писать функции для реакта
это нужно чтобы понять как на самом деле jsx выглядит
Для этого в файле introSection импортируем модуль React
на самом деле любой тег который есть в jsx это производная от метода React.createElement()
этот метод принимает 3 параметра
первый параметр это тег который мы передаем, второй параметр этой какие параметры будут у этого тега (то есть className или что-то подобное), третий это какие дети будут у этого тега, например какой либо текст в теге, либо вложенный тег, вложенный тег также создается с помощью React.createElement
return (
    React.createElement('section', null, 
        [
        React.createElement('h1', { className: 'centered' }, "Заголовок для ИНТРЫ"), 
        React.createElement('h3', { className: 'centered', style: { color: '#666' } }, 'Начало. тут текст для интры тут текст для интры тут текст для интры тут текст для интры тут текст для интры'),
        ]
        )
)
если вложенных несколько, то их нужно указывать списком в квадратных скобках
по факту в jsx на много удобнее, так как писать все объектами сложнее, и дольше, но вставлять какие-либо объекты также можно, например какой-либо стиль
также можно и функцию React.createElement записать в какую либо переменную и использовать ее как функцию
также нужно передавать элемент key, уникальное значение. Это нужно чтобы реакт правильно работал. Можно передать значения 1 и 2, как индексы. Передавать нужно его во втором параметре, там где className
посмотрим как эмулировать роутинг!!!!!!!!!!!
табы!!!!!!!
создадим файл TabsSection.jsx
пропишем туда 2 баттона
и создадим файл FeedbackSection.jsx
теперь реализуем такое, что при клике на introSection будет наш контент, а при клике на FeedbackSection будет обратная связь. То есть типа роутинг
для этого в App компоненте создадим State, именно в нем
const [tab, setTab] = useState('feedback')
также указали в нем параметр для состояния feedback, то есть по умолчанию будет страница feedback
пропишем условия, если tab равно main то отображаем наш контент, если feedback, то отображаем FeedbackSection

в TabsSection передается 2 кнопки, и в них свои состояния. То есть этот компоннет состоит из двух кнопок, в каждой есть свой функции. В App.jsx будут передаваться параметры сразу для двух кнопок
как работают кнопки!!!!!!!!!!
берем первую кнопку и тянем из нее в параметр klicker, в него передаем параметр (функцию) для изменения значения. Я назвал его (функцию) izmenenie. В него будет передаватся функция для изменения состояния
юзаем метод izmenenie, в него передаем функцию стрелочную, которая юзает функцию для изменения состояния
то есть
в App.jsx прописано так:
<TabsSection active={tab} izmenenie={(current) => setTab(current)} />
это как бы запуск функции с параметром current, этот код создает 2 кнопки с запуском функций с параметром
и сама функция прописана в файле TabSection.jsx для каждой кнопки отдельно
<Button isActive={active === 'main'} klicker={() => izmenenie('main')}>Главная</Button>
<Button isActive={active === 'feedback'} klicker={() => izmenenie('feedback') }>Обратная связь</Button>
то есть эту функцию для разных кнопок мы вызываем с разными значениями параметра current
ну и также есть еще параметр active, он меняет цвет кнопки в зависимости от состояния State

такая практика, когда мы в параметр компонента передаем функцию, и в эту эта функция является функцией изменения состояния, это хорошая практика. То есть, в самом компоненте нет состояния, а только параметр для него, а в главном компоненте есть состояние, и там мы юзаем функцию для изменения состояния, передавая ее в параметр компонента.
Компонент который содержит состояние - это умный компонент
Компонент который не содержит состояние - это глупый компонент (DUMP или дамп)
Лучше юзать так, чтобы были дампы, и в основном компоненте где вызывается дополнительный компонент, было состояние для вызванного компонента. То есть нужно чтобы не было внутренних состояний

Стилизация react приложений!!!!!!!!!!!!!!!!!!
Стили
стили могут перескакивать на другие компоненты
Можно сделать так чтобы они были локализованы на отдельный компонент
для примера локализуем стили для хедера
перенесем сначала код из лобщего css файла в отельный файл 
но назвать файл нужно по другому: Header.module.css
и импортировать его в файле Header.jsx
import classes from './Header.module.css'
тогда он будет работать как модуль
но импортируется объект с названием classes
лучше сделаем на кнопке, так как в хедере нет классов
переименуем файл со стилями кнопки в: Button.module.css
и импортируем модули в файле Button.jsx
import classes from "./Button.module.css"
на месте слова classes можно писать любое слово, но обычно принято называть этот импорт именно classes
если в консоли вывести этот объект classes то будет это:
первая кнопка
{button: '_button_1gmgn_1', active: '_active_1gmgn_29'}
active: "_active_1gmgn_29"
button: "_button_1gmgn_1"
[[Prototype]]: Object

вторая кнопка
{button: '_button_1gmgn_1', active: '_active_1gmgn_29'}
active: "_active_1gmgn_29"
button: "_button_1gmgn_1"
[[Prototype]]: Object

теперь уберем условия, которые были ранее в файле button.jsx
и пропишем следующее возврат функции:
 return (
        <button className={isActive ? `${classes.button} ${classes.active}`: classes.button} onClick={klicker} >{children}</button>
    )

вместо button active, прописали `${classes.button} ${classes.active}`, типа как шаблонизация

Теперь названия классов будут уникальными и не будут путаться с другими похожими названиями классов css. 

Есть еще доп библиотека для стилей!!!!!!!!!!!!!!!
установим ее:
npm install styled-components
и идем в файл Header.jsx
импортируем ее
import { styled } from 'styled-components'

и нужно сделать такой объект:
const Header_style = styled.header`
  height: 150px;
  display: flex;
  padding: 0 2rem;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #ccc;
`
он немного странный, потому что без проблема просто пишем сразу апострофы, и в них стили прописываем
и по факту это уже готовый реакт компонент, который можно юзать в нашем компоненте, только в return нужно писать наш тег header, название нашего объекта компонента со стилем Header_style
если после styled. прописать другой тег, то наш компонент будет с другим тегом

Перейдем к FeebackSection.jsx, и начнем работу с формами!!!!!!!!!!!!!!!
сделаем небольшую форму
<form>
    <input type="text" />
</form>
и стили к ней в файле index.css
называется клас .control
нужно состояние, которое будет следить за тем, что происходит в инпуте и селекте
const [name, setName] = useState('') это для name
const [reason, setReason] = useState('help') это для reason
в поля инпута передаем наши состояния
теперь туда нельзя ничего писать. Поэтому нужно передать обработчик событий onChange
и в него передать кастомную функцию:
function handleNameChange(event) {
        console.log(event.target.value)
        setName(event.target.value)
    }
она передает значение которое мы будем вводить
и меняет состояние
тоже самое сделаем для второго состояния
но также можно написать и инлайн функцию, а не обычную
onChange={ (event) => setReason(event.target.value) }

сделаем валидацию полей формы!!!!!!!!!!!!
сначала добавим красную обводку когда у нас поле пустое
для этого добавим стиль:
style={{
border:name.trim().length ? null : '2px solid red', 
}}
но лучше обводить красным позже когда будет действительно ошибка
для этого сделаем состояние
const [hasError, setHasError] = useState(false)

состояние не меняется пока не выполнится оставшееся часть функции. В тех функциях где у нас меняется состояние, сразу же использовать новое состояние нельзя. Но можно юзать это: event.target.value
например так:
setHasError(event.target.value.trim().length === 0)

и теперь стиль пропишем так:
style={{
border: hasError ? '2px solid red' : null,
}}
теперь сначала по умолчанию нет красной границы и в состоянии у нас false (когда false границы красной нет), а когда уже сотрем весь текст тогда состояние изменится на true, тогда будет красная граница

теперь нужно заблочить кнопку когда что-то не так!!!!!!!!!!!!
для этого добавим параметр disabled={hasError}
и теперь если есть ошибка, то disabled должно быть true
но его надо прописывать и в списке параметров компонента и в теле компонента в return
вместо этого можно в компоненте прописать параметр ...props
параметры с спредом!!!!!
...props 
то есть неопределенное колво параметров с любым именем
это связано как то со стилем
.button.disabled {
    cursor: not-allowed;
}
как он работает не понятно

То есть, теперь для этого компонента можно передавать параметры любые с любым названием и значеним или функцией. 
Кликер тоже работает, то есть можно так передавать через ...props любые параметры и эвенты
переделал вместо кликера оставил только  {...props}
и потом при вызове компонента Button, можно передавать любые названия параметров

Еще доп функционал для работы со стейтом!!!!!!!!!!!!!
Можно сделать переключатель состояния 
Добавил функцию
function toggleError() {
        setHasError(!hasError)
    }

и добавил кнопку
<Button onClick={toggleError}>Какой-то Error</Button>
теперь при нажатии на кнопку меняется состояние на обратное булевое значение
но есть фишка
если мы два раза пропишем setHasError(!hasError) , то есть вот так:
setHasError(!hasError)
setHasError(!hasError)
то состояние все равно будет меняться 1 раз. Так как не завершается работа всего блока и состояние не меняется.
Можно юзать по другому
Если передать в функцию изменения состояния какой один параметр, то в него автоматом записывается предыдущее значение то есть текущее. И с ним можно делать такие манипулиции как изменять булевое значение, оно будет меняться сразу. то есть написать нужно так:
setHasError((param) => !param)
setHasError((param) => !param)
тогда значение которое было по умолчанию подтянется в параметр с названием param и будет меняется как нам это нужно. 

function toggleError() {
        // setHasError(!hasError)
        // setHasError(!hasError)
        setHasError((param) => !param)
        setHasError((param) => !param)
    }

Также можно сделать одно общее состояние для нескольких полей
но теперь при изменении какого любо поля, у нас нам нужно передавать все нужные на поля, и даже те которые мы не меняли
setForm({
            name: event.target.value,
            hasError: event.target.value.trim().length === 0,
            reason: form.reason
        })

reason: form.reason тут у нас ничего не меняется, но передавать его надо. Если полей будет много, то прописывать будет проблемно
Можно писать спред функцию в виде ...
сет формы будет выглядеть так
setForm((prev) => ({
            ...prev,
            name: event.target.value,
            hasError: event.target.value.trim().length === 0,
        })

всместо всех параметров пишем это ...prev,
и потом все те параметры которые нам надо менять

также функцию changeReason перепишем так:
onChange={(event) =>
setForm((prev) => ({ ...prev, reason: event.target.value }))

это вывод объекта на странице: {JSON.stringify(form, null, 2)}
прописал его на странице для просмотра, вдруг пригодится

Есть еще механизмы которые позволяют взаимодействовать с input!!!!!!!!!!!!!!!!!!!!!!!
useRef
предположим у нас есть компонент, в нем есть обычное состояние, при котором мы при изменении состояния в какое-то текстовое поле пишем введенный текст автоматом. 
Если нам нужно чтобы только после нажатия Enter текст вводился, то нужно сделать обработчик событий onKeyDown и в него кидать состояние с тру или фолз, чтобы при нажатии Enter фолз менялся на тру и текст вводился. Но при этом он так и будет тру и будет дальше вводиться, пока мы не обновим страницу
Есть еще один хук, называется useRef. Его также нужно ипортировать из react
создадим константу и запишем в нее useRef()
далее в теге input добавим параметр ref, это встроенный параметр как и type value и тд
ему присвоим {inp} это переменная с useRef()
теперь можно удалить value, onChange из тега input и состояние для значения useState
и теперь в теге заголовка можно указать inp.current.value вместо значения состояния, как указывали ранее
Теперь после нажатия Enter будет записываться значение. Но только 1 раз пока
useState после изменения компонента каждый раз вызывает новый цикл рендеринга и из-за этого обновляется UI то есть страница сайта
useRef не вызывает цикл рендеринга. Менять его можно, но компонент не рендерится каждый раз. 
есть моменты когда можно сохранять определенное состояние в Ref и делиться этой инфой между различными компонентами

Тема Эффекты!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
создадим новый файл для компонента с эффектами EffectSection.jsx
там добавим компонент с таким же названием
в App.jsx добавим новый таб: {tab === 'effect' && <EffectSection /> }
И укажем что наш таб с названием effect будет по умолчанию в состоянии tab
и в TabSection.jsx добавим новую кнопку <Button isActive={active === 'effect'} onClick={() => izmenenie('effect') }>Эффект</Button>
это кнопка для tab по умолчанию
в файле EffectSection создадим кнопку <Button onClick={openModal}>Открыть информацию</Button>
и функцию openModal
Теперь создадим файл Modal.jsx в папке Modal, папку тоже перед этим создадим
Там напишем новую функцию Modal
в ней будет использовать тег <dialog>
у него есть доп функционал для модальных окон
далее в EffectSection добавим этот компонент Modal
в него добавим заголовок и параграф с текстом
но он не отобразится, так как диалог у нас не открыт, тег dialog нужно открыть
для этого в тег dialog нужно добавить параметр open
<dialog open>
добавим немного стилей для модалки для тега dialog
сделаем состояние для отображения модалки
const [modal, setModal] = useState(false)
и функцию 
function openModal() {
        setModal(true)
    }
которая будет переключать состояние
и в компоненте Modal добавим параметр open который будет прокидываться в свойство стандартное open тега dialog
также параметр open через ...props также работает. 
Вообще модалки должны находится поверх всех элементов
Можно юзать фишку с названием порталы
в компонент Modal импортируем это
import { createPortal } from 'react-dom'
теперь вместо jsx будем возвращать это:
createPortal(
        <dialog open={open}>{children}</dialog>,
        document.getElementById('modal')
        )
и в html документе мы добавим новый тег div
<div id="modal"></div>
Теперь наша модалка будет поверх других элементов
Нет затемнения, но его можно сделать
для этого сделаем useRef в Modal.jsx
и пропишем условие
if (open) {
        dialog.current.showModal()
    } else {
        dialog.current.close()
    }
но это условие не работает, так как в current еще ничего нет оно undefined

Нужно юзать хук useEffect!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Он используется в компонентах или кастомных хуках
конструкция
он принимает 2 параметра:
первый параметр это функция колбэк, то есть она будет выполняться когда выполнится сам эффект
второй параметр это массив зависимостей deps, от чего зависит эффект
useEffect(() => {}, [])
с помощью этой функции мы регаем задачи которые реакт компоненту нужно выполнить
эффекты срабатывают когда завершится код функции, пройдет рендеринг jsx и потом только срабатывают эффекты
задачу useEffect он только регистрирует, а выполняет ее потом когда уже пройдет весь код
перенесем наше условие в файле Modal.jsx в колбэк useEffect
уберем open={open} из тега dialog
в массиве зависимостей мы указываем те состояния, которые являются реактивными, то есть которые влияют на перерисовку компонентов. Теперь появляется затемнение всех элементов кроме модалки когда она открывается
добавим в модальное окно кнопку для закрытия модального окна
для этого в файле EffectSection.jsx в теге Modal добавим Button с событием onClick в котором будет функция которая запускается setModal(false)
тогда состояние будет false и модальное окно исчезнет
Мы ранее указывали счетчик времени сверху страницы через интенвал. Это не совсем верно
Нужно использовать эффект
Так как в случае если мы удалим компонент (в нашем случае хедер не удаляется, но если это будет какой то другой компонент который будет исчезать, то время будет продолжать тикать и будет утечка памяти)
по правильному нужно всегда чистить эти таймеры
и тут нам поможет useEffect
пропишем в файле Header.jsx useEffect
пока список зависимостей будет пустым, то есть в квадратных скобках будет пусто
наш тег там постоянно рендерится, но эффекст постоянно не юзается, так как нет зависимостей
теперь мы наш интервал внесем в колбэк useEffect
для примера в уроке он сделал состояние когда хедер исчезает через 3 секунды, но интервал продолжает тикать. В useEffect можно сделать очистку интервала
сделаем внтури useEffect стрелочную функцию 
return () => {
      clearInterval()
      console.log('Super Effect')
    }
которая будет возвращаться когда компонент исчезает, я так понял. Срабатывает код из эффекта когда компонент появился то есть отрендерился, а возврат срабатывает когда компонент исчез. Как работает по какой логике хз
эффект срабатывает когда компонент будет зарендерен

Бэкенд!!!!!!!!!!!!!!!!!!!!!!!
также можно делать запросы к серверу через useEffect и асинхронно выводить какие либо элементы
сделаем useState loading
запросы к серверу нужно делать именно через useEffect. Если делать по обычному fetch то реакт может сломаться или уйти в рекурсию
для начала набор параметров будет пустым

и сделаем функцию для api запроса
async function fetchUsers() {
        setLoading(true)
        const response = await fetch('https://jsonplaceholder.typicode.com/users')
        const data_users = await response.json()
        setUsers(data_users)
        setLoading(false)
    }

и вызывать ее будет в useEffect
вне useEffect эта функция работать не будет
и сделаем внизу объектик 
{loading && <p>Загрузка</p>}
то есть когда у нас будет срабатывать эффект, то будет появляться надпись Загрузка

и далее отобразим список пользователей
{!loading && (
                <ul>
                    {users.map((user) => (
                        <li key={user.id}>{user.name}</li>
                        ))}
                </ul>
                )}
в девтоолс их можно посмотреть на вкладке network в разделе Fetch/XHR
там будет наш объект users и в нем список пользаков

ЗАПОМНИТЬ: В СТИЛЯХ ПИШЕМ ЧЕРЕЗ ДВОЕТОЧИЕ И В JSON В ДРУГИХ СЛУЧАЯХ ЗНАК =

исправление предыдущего кода!!!!!!!!!!!!!
в теории можно попасть в цикличную зависимость
и в нетворке каждый раз появляется users при нажатии кнопки эффект
https://jsonplaceholder.typicode.com/users
jsonplaceholder сайт перестал работать

взял апи отсюда, но через axios
https://reqres.in/api/users?page=1

useCallback!!!!!!!!!!!!!!!
можно сделать просто, прописав нашу функцию которую мы вызываем в useEffect
тогда будет все норм, и зацикливания не будет. Но это не очень продвинутый вариант
есть такая фича, если сделать 2 переменные в одинаковыми значениями объектов, оне не будут полностью идентичны, то есть сравнении на === будет фолз. Это из-за того что меняется указатель в памяти. 
поэтому нужно юзать колбек, так как реакт каждый раз перерисовывает страницу при изменении 
колбэк кеширует функцию и не перерисовывает
создадим функцию 
const fetchUsers = useCallback(async () => {    
        setLoading(true)
        await axios.get('https://reqres.in/api/users?page=1').then((res) =>{
            setUsers(res.data.data) })
        setLoading(false)
    
    }, [])

также вызовем эту функцию в useEffect и в useEffect нужно добавить эту функцию fetchUsers в список зависимостей

Кастомные хуки!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Это для понимания работы хуков
будем фильтровать пользаков динамически
создадим папку hooks
в ней создадим файл useInput.js
jsx в нем не будет
обычно в input есть значения value и onChange и мы работаем со state
хуки useState useEffect можно юзать только в рамках компонентов или только в рамках кастомных хуков
кастомный хук это функция, в которой мы юзаем другие хуки
пропишем такую функцию это наш хук:
export default function useInput(defaultValue = "") {
    const [value, setValue] = useState(defaultValue)

    return {
        value, 
        onChange: (event) => setValue(event.target.value),
    }
}

теперь в файле EffectSection.jsx 
пропишем вызов нашеего кастомного хука 
const input = useInput()
и в теге где мы выводили пользаков, там в инпуте пропишем это {...input} это будет означать что мы можем юзать все значения, которые возвращает наш хук
Теперь мы можем юзать все то что будет присутствовать в нашем input
сделали фильтр если текст надпись содержится в именах, то они сразу отобразятся
{!loading && (
                <>
                    <input type="text" className="control" {...input} />
                    <h6>{input.value}</h6>
                    <ul>
                        {users.filter((el) =>
                            el.name.toLowerCase().includes(input.value.toLowerCase())
                            )
                        .map((user) => (
                            <li key={user.id}>{user.name}</li>
                            ))}
                    </ul>
                </>
                )}



Непомнящий. Он хорошо преподает!!!!!!!!!!!!!!!!!!
https://www.youtube.com/@mishanep/playlists













